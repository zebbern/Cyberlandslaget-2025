## Original Writeup From lillieCan Taken From:

<code>[**https://ctf.lillie.sh/blog/forensics/futuristic-malware/**](https://ctf.lillie.sh/blog/forensics/futuristic-malware/)</code> 

<br>

# Futuristic Malware

**Challenge Prompt:**

> I gave you modern malware https://github.com/olnor18/writeup/tree/master/DDC/2024/ModernMalware.  
> How do you like some futuristic malware???

**Files provided:**  
- `invoice.pdf.DMP.exe`  
- `invoice.pdf.exe`  
- `capture.pcapng`

---

## Initial Thoughts

From the files provided, the challenge likely involves:
- Extracting data from the memory dump
- Analyzing traffic from the Wireshark capture
- Reverse engineering the malware binary

---

## First Steps

Used `strings` and `binwalk` for a quick overview of the files.

Also ran `AESKeyFind` on the memory dump ‚Äî found a few AES keys (as in previous forensics challenges).

---

## Reversing

I used Detect It Easy to figure out the binary uses golang, so I open it up in Ida Pro as that is good with golang binaries. I found out quickly that it encodes payloads first in base64, and then encrypts using AES CBC. So I believe one of the keys I have found could be the correct one.

Discovered:
- Payloads are base64 encoded
- Then encrypted with AES CBC

Code for decrypting the payload:

```c
    v18 = encoding_base64__ptr_Encoding_DecodeString(encoding_base64_StdEncoding, a1, a2);
    v16 = a1;
    v17 = v4;
    v5 = runtime_stringtoslicebyte(v15, *(_QWORD *)runtime_bss, *(_QWORD *)(runtime_bss + 8));
    crypto_sha256_Sum256(v5);
    v14[0] = v12;
    v14[1] = v13;
    p__16_uint8 = (_16_uint8 *)runtime_newobject(&RTYPE__16_uint8);
    memset(p__16_uint8, 34, sizeof(_16_uint8));
    v6 = crypto_aes_NewCipher(v14, 32LL, 32LL);
    v7 = crypto_cipher_NewCBCDecrypter(v6, 32LL, p__16_uint8, 16LL, 16LL);
```

---

## Looking at dump

I started looking into the dump, and noticed there were base64 strings which could be the data malware sends. I copied one of the shorter base64 texts in the dump, and I tried out each of the keys. One of the keys decrypted it but I didn‚Äôt have the IV, so the first bytes are still ‚Äúencrypted‚Äù.

I searched and found the plaintext in the dump, and I xored the plaintext with what I encrypted to get the IV. This is the weakness with CBC, you can easily get the IV if have a key and know the plaintext.

## Base64 Padding

I tried out the strings that were longer, but they seemed to not encrypt. So I thought it could be broken. I then remember you can pad or remove parts of incomplete base64, and that worked.

I started padding to get out different parts of the base64.

## Cheese?

I padded each of the base64 to get out all of the information in hopes of finding something. After a few more padded base64, I found this.

```
"Root","Flag","","DDC{g0d_1_h4t3_http3_m4tur1ty}","","","","0","2024-08-12T10:14:05Z","2024-08-12T10:12:46Z"
```

---

## üèÅ Flag

```
DDC{g0d_1_h4t3_http3_m4tur1ty}
```
